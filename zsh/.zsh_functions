#!/bin/zsh

mojo_project() {
  if [ -z "$1" ]; then 
    echo "Usage: mojo_project <project_name>"
    return 1 
  fi 
  magic init "$1" --format mojoproject && rm -rf "$1"/.gitignore && rm -rf "$1"/.gitattributes
}

qr() {
  if [ -z "$1" ]; then
    echo "Usage: qr <link_to_website>"
    return 1
  fi
  qrterm "$1"
}

file_upload() {
  if [ -z "$1" ]; then
    echo "Usage: file_upload <path_to_file>"
    return 1
  fi

  PRIMARY_HOST="https://send.mni.li"
  SECONDARY_HOST="https://send.richy.sh"

  upload_with_host() {
    local host="$1"
    ffsend upload --host "$host" "$2" 2>/dev/null | grep -o 'https://[^ ]*'
  }

  # Try primary
  if curl -fs --max-time 5 "$PRIMARY_HOST" > /dev/null; then
    echo "Using primary host: $PRIMARY_HOST"
    link=$(upload_with_host "$PRIMARY_HOST" "$1")
  fi

  # Try secondary if primary failed
  if [ -z "$link" ] && curl -fs --max-time 5 "$SECONDARY_HOST" > /dev/null; then
    echo "Primary failed, using secondary host: $SECONDARY_HOST"
    link=$(upload_with_host "$SECONDARY_HOST" "$1")
  fi

  # Final fallback: default ffsend host
  if [ -z "$link" ]; then
    echo "Primary and secondary unavailable, falling back to default"
    link=$(ffsend upload "$1" 2>/dev/null | grep -o 'https://[^ ]*')
  fi

  if [ -z "$link" ]; then
    echo "Upload failed."
    return 1
  fi

  # Copy first, then notify
  printf "%s" "$link" | wl-copy
  notify-send "File Upload" "Link copied to clipboard"

  echo "Link copied to clipboard:"
  echo "$link"
  echo
  qrterm "$link"
}

# Function to add, commit, and push to all Git remotes with meteor for conventional commits
acp() {
    # Check for fzf
    if ! command -v fzf >/dev/null 2>&1; then
        echo 'Error: fzf is not installed. Please install it from https://github.com/junegunn/fzf'
        return 1
    fi

    # Stage all changes
    git add .

    # 1. Define Commit Types with Descriptions
    local choices=(
        "feat : A new feature"
        "fix : A bug fix"
        "docs : Documentation only changes"
        "style : Changes that do not affect the meaning of the code (white-space, formatting, etc)"
        "refactor : A code change that neither fixes a bug nor adds a feature"
        "perf : A code change that improves performance"
        "test : Adding missing tests or correcting existing tests"
        "build : Changes that affect the build system or external dependencies"
        "ci : Changes to our CI configuration files and scripts"
        "chore : Other changes that don't modify src or test files"
        "revert : Reverts a previous commit"
    )

    # 2. Select Commit Type using fzf
    # We use printf to feed the array elements as new lines into fzf
    echo "Choose commit type:"
    local selected
    selected=$(printf "%s\n" "${choices[@]}" | fzf --reverse --header "Select Commit Type")

    # Handle cancellation
    if [ -z "$selected" ]; then
        echo 'Error: No commit type selected.'
        return 1
    fi

    # 3. Extract the type (Clean the string)
    # Removes everything starting from " :" to the end
    local type
    type="${selected%% :*}"

    # 4. Commit
    git commit -as -e -m "$type(): "
    
    # Check if commit was successful
    if [ $? -ne 0 ]; then
        echo 'Error: Commit failed or was cancelled'
        return 1
    fi

    # 5. Prompt for branch name using fzf
    local branch
    branch=$(git branch --format='%(refname:short)' | fzf --reverse --header "Select Branch")
    
    if [ -z "$branch" ]; then
        echo 'Error: Branch name cannot be empty'
        return 1
    fi

    # Verify branch exists
    if ! git rev-parse --verify "$branch" >/dev/null 2>&1; then
        echo "Error: Branch $branch does not exist"
        return 1
    fi

    # Checkout branch if needed
    local current_branch
    current_branch=$(git branch --show-current)
    if [ "$current_branch" != "$branch" ]; then
        git checkout "$branch"
    fi

    # Push to all remotes
    local remotes
    remotes=($(git remote))

    for remote in "${remotes[@]}"; do
        echo "Pushing to remote: $remote"
        git push "$remote" "$branch"
    done

    echo 'Changes added, committed, and pushed to all remotes'
}

# Function to push to origin only
acpo() {
    # Check if meteor is installed
    if ! command -v meteor >/dev/null 2>&1; then
        echo 'Error: meteor is not installed. Install with: go install github.com/stefanlogue/meteor@latest'
        return 1
    fi

    # Stage all changes
    git add .

    # Use meteor for conventional commit (interactive)
    meteor
    
    # Check if commit was successful
    if [ $? -ne 0 ]; then
        echo 'Error: Commit failed or was cancelled'
        return 1
    fi

    # Check if gum is installed for branch selection
    if ! command -v gum >/dev/null 2>&1; then
        echo 'Error: gum is not installed. Please install it from https://github.com/charmbracelet/gum'
        return 1
    fi

    # Prompt for branch name using gum
    branch=$(git branch | gum choose | sed 's/^* //')
    if [ -z "$branch" ]; then
        echo 'Error: Branch name cannot be empty'
        return 1
    fi

    # Verify branch exists
    if ! git rev-parse --verify "$branch" >/dev/null 2>&1; then
        echo "Error: Branch $branch does not exist"
        return 1
    fi

    # Checkout the specified branch (only if not already on it)
    current_branch=$(git branch --show-current)
    if [ "$current_branch" != "$branch" ]; then
        git checkout "$branch"
    fi

    # Push to origin only
    echo "Pushing to remote: origin"
    git push origin "$branch"

    echo 'Changes added, committed with conventional format, and pushed to origin'
}

# Function to add, commit, and push to all Git remotes with meteor for conventional commits
acpf() {
    # Check if meteor is installed
    if ! command -v meteor >/dev/null 2>&1; then
        echo 'Error: meteor is not installed. Install with: go install github.com/stefanlogue/meteor@latest'
        return 1
    fi

    # Stage all changes
    git add .

    # Use meteor for conventional commit (interactive)
    meteor
    
    # Check if commit was successful
    if [ $? -ne 0 ]; then
        echo 'Error: Commit failed or was cancelled'
        return 1
    fi

    # Check if gum is installed for branch selection
    if ! command -v gum >/dev/null 2>&1; then
        echo 'Error: gum is not installed. Please install it from https://github.com/charmbracelet/gum'
        return 1
    fi

    # Prompt for branch name using gum
    branch=$(git branch | gum choose | sed 's/^* //')
    if [ -z "$branch" ]; then
        echo 'Error: Branch name cannot be empty'
        return 1
    fi

    # Verify branch exists
    if ! git rev-parse --verify "$branch" >/dev/null 2>&1; then
        echo "Error: Branch $branch does not exist"
        return 1
    fi

    # Checkout the specified branch (only if not already on it)
    current_branch=$(git branch --show-current)
    if [ "$current_branch" != "$branch" ]; then
        git checkout "$branch"
    fi

    # Get all remote names into an array
    remotes=($(git remote))

    # Push to all remotes
    for remote in "${remotes[@]}"; do
        echo "Pushing to remote: $remote"
        git push --force "$remote" "$branch"
    done

    echo 'Changes added, committed with conventional format, and pushed to all remotes'
}

form_create() {
    local num_questions code
    # Prompt for number of questions
    num_questions=$(gum input --prompt "Enter number of questions: " --placeholder "e.g., 5")
    
    # Validate number of questions is a positive integer
    if [[ ! "$num_questions" =~ ^[0-9]+$ ]] || [ "$num_questions" -le 0 ]; then
        echo "Error: Please enter a valid positive number"
        return 1
    fi
    
    # Prompt for code
    code=$(gum input --prompt "Enter form code: " --placeholder "e.g., myform123")
    
    # Validate code is not empty
    if [ -z "$code" ]; then
        echo "Error: Code cannot be empty"
        return 1
    fi
    
    # Execute ssh command to create bashform
    ssh -t bashform.me create "$num_questions" "$code"
}

function ans_form() {
    local code
    # Prompt for form code using gum input
    code=$(gum input --prompt "Enter form code: " --placeholder "e.g., myform123")
    
    # Validate code is not empty
    if [ -z "$code" ]; then
        echo "Error: Code cannot be empty"
        return 1
    fi
    
    # Execute ssh command to answer the form
    ssh -t bashform.me form "$code"
}

function view_forms() {
    # Execute ssh command to view all form answers
    ssh -t bashform.me forms
}

pdf_manager() {
    # Check if gum is installed
    if ! command -v gum &> /dev/null; then
        echo "Error: gum is not installed. Install it with: brew install gum"
        return 1
    fi

    # Main menu
    local action=$(gum choose "Merge PDFs" "Separate PDF" "Remove Pages from PDF")
    
    case $action in
        "Merge PDFs")
            merge_pdfs
            ;;
        "Separate PDF")
            separate_pdf
            ;;
        "Remove Pages from PDF")
            remove_pages
            ;;
        *)
            echo "Operation cancelled"
            return 0
            ;;
    esac
}

merge_pdfs() {
    echo "üìö Merging PDFs"
    
    # Get list of PDF files in current directory
    local pdf_files=(*.pdf)
    
    if [[ ${#pdf_files[@]} -eq 0 ]] || [[ "${pdf_files[1]}" == "*.pdf" ]]; then
        echo "‚ùå No PDF files found in current directory"
        return 1
    fi
    
    # Multi-select PDF files to merge
    local selected_files=$(gum choose --no-limit "${pdf_files[@]}")
    
    if [[ -z "$selected_files" ]]; then
        echo "‚ùå No files selected"
        return 1
    fi
    
    # Get output filename
    local output_file=$(gum input --placeholder "Enter output filename (e.g., merged.pdf)")
    
    if [[ -z "$output_file" ]]; then
        echo "‚ùå No output filename provided"
        return 1
    fi
    
    # Ensure .pdf extension
    if [[ "$output_file" != *.pdf ]]; then
        output_file="${output_file}.pdf"
    fi
    
    # Confirm before merging
    echo "Selected files:"
    echo "$selected_files" | while read -r file; do
        echo "  - $file"
    done
    echo "Output: $output_file"
    
    if gum confirm "Proceed with merge?"; then
        # Convert newline-separated string to array for pdfunite
        local files_array=()
        while IFS= read -r file; do
            files_array+=("$file")
        done <<< "$selected_files"
        
        pdfunite "${files_array[@]}" "$output_file"
        echo "‚úÖ PDFs merged successfully: $output_file"
    else
        echo "‚ùå Merge cancelled"
    fi
}

separate_pdf() {
    echo "üìÑ Separating PDF"
    
    # Get list of PDF files
    local pdf_files=(*.pdf)
    
    if [[ ${#pdf_files[@]} -eq 0 ]] || [[ "${pdf_files[1]}" == "*.pdf" ]]; then
        echo "‚ùå No PDF files found in current directory"
        return 1
    fi
    
    # Select PDF to separate
    local input_file=$(gum choose "${pdf_files[@]}")
    
    if [[ -z "$input_file" ]]; then
        echo "‚ùå No file selected"
        return 1
    fi
    
    # Get base name for output files
    local base_name=$(gum input --placeholder "Enter base name for output files (default: page)" --value "page")
    
    if [[ -z "$base_name" ]]; then
        base_name="page"
    fi
    
    if gum confirm "Separate $input_file into individual pages?"; then
        pdfseparate "$input_file" "${base_name}-%d.pdf"
        echo "‚úÖ PDF separated successfully with pattern: ${base_name}-%d.pdf"
    else
        echo "‚ùå Separation cancelled"
    fi
}

remove_pages() {
    echo "‚úÇÔ∏è  Removing Pages from PDF"
    
    # Get list of PDF files
    local pdf_files=(*.pdf)
    
    if [[ ${#pdf_files[@]} -eq 0 ]] || [[ "${pdf_files[1]}" == "*.pdf" ]]; then
        echo "‚ùå No PDF files found in current directory"
        return 1
    fi
    
    # Select PDF file
    local input_file=$(gum choose "${pdf_files[@]}")
    
    if [[ -z "$input_file" ]]; then
        echo "‚ùå No file selected"
        return 1
    fi
    
    # Get total page count (requires pdfinfo from poppler-utils)
    local total_pages
    if command -v pdfinfo &> /dev/null; then
        total_pages=$(pdfinfo "$input_file" | grep "Pages:" | awk '{print $2}')
        echo "üìä Total pages in $input_file: $total_pages"
    else
        echo "‚ö†Ô∏è  pdfinfo not available. Cannot show page count."
        total_pages=$(gum input --placeholder "Enter total number of pages in the PDF")
    fi
    
    # Get pages to remove
    local pages_to_remove=$(gum input --placeholder "Enter page numbers to remove (e.g., 2,5,7-9)")
    
    if [[ -z "$pages_to_remove" ]]; then
        echo "‚ùå No pages specified"
        return 1
    fi
    
    # Get output filename
    local output_file=$(gum input --placeholder "Enter output filename" --value "${input_file%.*}_modified.pdf")
    
    if [[ -z "$output_file" ]]; then
        echo "‚ùå No output filename provided"
        return 1
    fi
    
    # Ensure .pdf extension
    if [[ "$output_file" != *.pdf ]]; then
        output_file="${output_file}.pdf"
    fi
    
    echo "Input: $input_file"
    echo "Pages to remove: $pages_to_remove"
    echo "Output: $output_file"
    
    if gum confirm "Proceed with page removal?"; then
        # Create temporary directory
        local temp_dir=$(mktemp -d)
        local base_name="temp_page"
        
        # Separate all pages
        echo "üîÑ Separating pages..."
        pdfseparate "$input_file" "$temp_dir/${base_name}-%d.pdf"
        
        # Build array of pages to keep
        local pages_to_keep=()
        local pages_to_remove_array=()
        
        # Parse pages to remove (handle ranges and individual pages)
        # Use zsh-specific array splitting to fix the read -ra issue
        local remove_parts=(${(s:,:)pages_to_remove})
        
        for part in "${remove_parts[@]}"; do
            part=$(echo "$part" | tr -d ' ')  # Remove spaces
            if [[ "$part" == *-* ]]; then
                # Handle range (e.g., 7-9)
                local start=${part%-*}
                local end=${part#*-}
                for ((i=start; i<=end; i++)); do
                    pages_to_remove_array+=($i)
                done
            else
                # Handle individual page
                pages_to_remove_array+=($part)
            fi
        done
        
        # Build list of pages to keep
        for ((i=1; i<=total_pages; i++)); do
            local should_remove=false
            for remove_page in "${pages_to_remove_array[@]}"; do
                if [[ $i -eq $remove_page ]]; then
                    should_remove=true
                    break
                fi
            done
            if [[ $should_remove == false ]]; then
                if [[ -f "$temp_dir/${base_name}-$i.pdf" ]]; then
                    pages_to_keep+=("$temp_dir/${base_name}-$i.pdf")
                fi
            fi
        done
        
        if [[ ${#pages_to_keep[@]} -eq 0 ]]; then
            echo "‚ùå No pages would remain after removal"
            rm -rf "$temp_dir"
            return 1
        fi
        
        # Merge remaining pages
        echo "üîÑ Merging remaining pages..."
        pdfunite "${pages_to_keep[@]}" "$output_file"
        
        # Clean up temporary files
        rm -rf "$temp_dir"
        
        echo "‚úÖ Pages removed successfully: $output_file"
        echo "üìä Kept $(( total_pages - ${#pages_to_remove_array[@]} )) of $total_pages pages"
    else
        echo "‚ùå Operation cancelled"
    fi
}

wsend() {
    local script_path="$HOME/dotfiles/zsh/.local/bin/send_file.sh"
    
    if [[ -x "$script_path" ]]; then
        "$script_path" "$@"
    else
        echo "Error: Script not found or not executable at $script_path"
        return 1
    fi
}

wreceive() {
    local script_path="$HOME/dotfiles/zsh/.local/bin/receive_file.sh"
    
    if [[ -x "$script_path" ]]; then
        "$script_path" "$@"
    else
        echo "Error: receive_file.sh not found or not executable at $script_path"
        return 1
    fi
}

mkproj() {
    local script_path="$HOME/dotfiles/zsh/.local/bin/mkproj.sh"
    
    if [[ -x "$script_path" ]]; then
        "$script_path" "$@"
    else
        echo "Error: mkproj.sh not found or not executable at $script_path"
        return 1
    fi
}

gist_manager() {
    local script_path="$HOME/dotfiles/zsh/.local/bin/gist_manager.sh"
    
    if [[ -x "$script_path" ]]; then
        "$script_path" "$@"
    else
        echo "Error: gist_manager.sh not found or not executable at $script_path"
        return 1
    fi
}

mp4_to_gif() {
    local script_path="$HOME/dotfiles/zsh/.local/bin/mp4_to_gif.sh"
    
    if [[ -x "$script_path" ]]; then
        "$script_path" "$@"
    else
        echo "Error: mp4_to_gif.sh not found or not executable at $script_path"
        return 1
    fi
}

aoci() {
    local script_path="$HOME/dotfiles/zsh/.local/bin/aoci.sh"
    
    if [[ -x "$script_path" ]]; then
        "$script_path" "$@"
    else
        echo "Error: aoci.sh not found or not executable at $script_path"
        return 1
    fi
}

notes() {
    local script_path="$HOME/dotfiles/zsh/.local/bin/notes.sh"
    
    if [[ -x "$script_path" ]]; then
        "$script_path" "$@"
    else
        echo "Error: notes.sh not found or not executable at $script_path"
        return 1
    fi
}

send_email() {
    local script_path="$HOME/dotfiles/zsh/.local/bin/send_email.sh"
    
    if [[ -x "$script_path" ]]; then
        "$script_path" "$@"
    else
        echo "Error: send_email.sh not found or not executable at $script_path"
        return 1
    fi
}

stm32flash() {
    # Adjust this path if you saved the file somewhere else
    local script_path="$HOME/dotfiles/zsh/.local/bin/stm32flash.sh"

    if [[ -x "$script_path" ]]; then
        "$script_path" "$@"
    else
        echo "Error: Script not found or not executable at $script_path"
        return 1
    fi
}

tree_copy() {
    local target="."
    local eza_opts=""

    # Parse arguments
    for arg in "$@"; do
        if [[ "$arg" == "--all" || "$arg" == "-a" || "$arg" == "--hidden" ]]; then
            eza_opts="--all"
        else
            target="$arg"
        fi
    done

    # Run eza tree (with optional --all) and copy to clipboard
    eza --tree $eza_opts "$target" | wl-copy

    # Confirm execution
    if [[ -n "$eza_opts" ]]; then
        echo "Directory tree of '$target' (including hidden files) copied to clipboard."
    else
        echo "Directory tree of '$target' copied to clipboard."
    fi
}

function img() {
    
    if [[ -n "$WEZTERM_EXECUTABLE" ]]; then
        wezterm imgcat "$@"
    elif [[ "$TERM_PROGRAM" == "ghostty" ]] || [[ "$TERM_PROGRAM" == "kitty" ]]; then
        kitten icat "$@"
    else
        loupe "$@"
    fi
}

# --- Daily Kanji Quiz Startup ---
function run_daily_kanji_check() {
    # Check if the binary exists in PATH (works for .local/bin or .cargo/bin)
    if command -v daily_kanji >/dev/null 2>&1; then
        daily_kanji
    fi
}

